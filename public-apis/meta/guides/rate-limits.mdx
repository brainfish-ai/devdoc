---
title: Rate Limits
description: Understanding rate limits across Meta Platform APIs
---

Meta Platform APIs enforce rate limits to ensure fair usage and platform stability.

## Rate Limit Types

### Application-Level
Limits based on your app's total API calls across all users.

### User-Level
Limits based on individual user's API calls through your app.

## Limits by API

<Tabs>
  <Tab title="Facebook Conversions">
    | Resource | Limit |
    |----------|-------|
    | Events per request | 1,000 |
    | Requests per pixel | Based on app tier |
  </Tab>
  <Tab title="Instagram">
    | Resource | Limit |
    |----------|-------|
    | Content Publishing | 25 posts per 24 hours |
    | API Calls | 200 calls per user per hour |
    | Hashtag Search | 30 unique hashtags per 7 days |
  </Tab>
  <Tab title="WhatsApp">
    | Tier | Messages per 24 hours |
    |------|----------------------|
    | Tier 1 | 1,000 |
    | Tier 2 | 10,000 |
    | Tier 3 | 100,000 |
    | Tier 4 | Unlimited |
  </Tab>
  <Tab title="Threads">
    | Resource | Limit |
    |----------|-------|
    | API Calls | 200 calls per user per hour |
    | Content Publishing | Subject to platform limits |
  </Tab>
</Tabs>

## Handling Rate Limits

### Check Response Headers

```
X-App-Usage: {"call_count":28,"total_cputime":25,"total_time":55}
X-Business-Use-Case-Usage: {...}
```

### Error Response

```json
{
  "error": {
    "message": "Application request limit reached",
    "type": "OAuthException",
    "code": 4,
    "fbtrace_id": "..."
  }
}
```

## Best Practices

1. **Implement exponential backoff** when rate limited
2. **Cache responses** to reduce API calls
3. **Batch requests** where possible
4. **Monitor usage** via response headers
5. **Use webhooks** instead of polling

## Exponential Backoff Example

```javascript
async function apiCallWithRetry(fn, maxRetries = 5) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (error.code === 4 && i < maxRetries - 1) {
        const delay = Math.pow(2, i) * 1000;
        await new Promise(r => setTimeout(r, delay));
        continue;
      }
      throw error;
    }
  }
}
```
